"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.plugin = exports.DnsPlugin = void 0;
const core_1 = require("@opentelemetry/core");
const api_1 = require("@opentelemetry/api");
const semver = require("semver");
const shimmer = require("shimmer");
const AttributeNames_1 = require("./enums/AttributeNames");
const utils = require("./utils");
const version_1 = require("./version");
/**
 * Dns instrumentation plugin for Opentelemetry
 */
class DnsPlugin extends core_1.BasePlugin {
    constructor(moduleName, version) {
        super('@opentelemetry/plugin-dns', version_1.VERSION);
        this.moduleName = moduleName;
        this.version = version;
        // For now component is equal to moduleName but it can change in the future.
        this.component = this.moduleName;
        this._config = {};
    }
    /** Patches DNS functions. */
    patch() {
        this._logger.debug('applying patch to %s@%s', this.moduleName, this.version);
        shimmer.wrap(this._moduleExports, 'lookup', 
        // tslint:disable-next-line:no-any
        this._getLookup());
        // new promise methods in node >= 10.6.0
        // https://nodejs.org/docs/latest/api/dns.html#dns_dnspromises_lookup_hostname_options
        if (semver.gte(this.version, '10.6.0')) {
            shimmer.wrap(this._moduleExports.promises, 'lookup', 
            // tslint:disable-next-line:no-any
            this._getLookup());
        }
        return this._moduleExports;
    }
    /** Unpatches all DNS patched function. */
    unpatch() {
        shimmer.unwrap(this._moduleExports, 'lookup');
        if (semver.gte(this.version, '10.6.0')) {
            shimmer.unwrap(this._moduleExports.promises, 'lookup');
        }
    }
    /**
     * Get the patched lookup function
     */
    _getLookup() {
        return (original) => {
            return this._getPatchLookupFunction(original);
        };
    }
    /**
     * Creates spans for lookup operations, restoring spans' context if applied.
     */
    _getPatchLookupFunction(original) {
        this._logger.debug('patch lookup function');
        const plugin = this;
        return function patchedLookup(hostname, ...args) {
            if (utils.isIgnored(hostname, plugin._config.ignoreHostnames, (e) => plugin._logger.error('caught ignoreHostname error: ', e))) {
                return original.apply(this, [hostname, ...args]);
            }
            const argsCount = args.length;
            plugin._logger.debug('wrap lookup callback function and starts span');
            const name = utils.getOperationName('lookup');
            const span = plugin._startDnsSpan(name, {
                attributes: {
                    [AttributeNames_1.AttributeNames.PEER_HOSTNAME]: hostname,
                },
            });
            const originalCallback = args[argsCount - 1];
            if (typeof originalCallback === 'function') {
                args[argsCount - 1] = plugin._wrapLookupCallback(originalCallback, args[argsCount - 2], span);
                return plugin._safeExecute(span, () => 
                // tslint:disable-next-line:no-any
                original.apply(this, [
                    hostname,
                    ...args,
                ]));
            }
            else {
                const promise = plugin._safeExecute(span, () => original.apply(this, [hostname, ...args]));
                promise.then(result => {
                    utils.setLookupAttributes(span, result);
                    span.end();
                }, (e) => {
                    utils.setError(e, span, plugin.version);
                    span.end();
                });
                return promise;
            }
        };
    }
    /**
     * Start a new span with default attributes and kind
     */
    _startDnsSpan(name, options) {
        return this._tracer
            .startSpan(name, Object.assign(Object.assign({}, options), { kind: api_1.SpanKind.CLIENT }))
            .setAttribute(AttributeNames_1.AttributeNames.COMPONENT, this.component);
    }
    /**
     * Wrap lookup callback function
     */
    _wrapLookupCallback(original, options, span) {
        const plugin = this;
        return function wrappedLookupCallback(err, address, family) {
            plugin._logger.debug('executing wrapped lookup callback function');
            if (err !== null) {
                utils.setError(err, span, plugin.version);
            }
            else {
                utils.setLookupAttributes(span, address, family);
            }
            span.end();
            plugin._logger.debug('executing original lookup callback function');
            return original.apply(this, arguments);
        };
    }
    /**
     * Safely handle "execute" callback
     */
    _safeExecute(span, execute) {
        try {
            return execute();
        }
        catch (error) {
            utils.setError(error, span, this.version);
            span.end();
            throw error;
        }
    }
}
exports.DnsPlugin = DnsPlugin;
exports.plugin = new DnsPlugin('dns', process.versions.node);
//# sourceMappingURL=dns.js.map