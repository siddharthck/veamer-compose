"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isIgnored = exports.satisfiesPattern = exports.setLookupAttributes = exports.parseErrorCode = exports.getOperationName = exports.getFamilyAttribute = exports.setError = void 0;
const api_1 = require("@opentelemetry/api");
const AttributeNames_1 = require("./enums/AttributeNames");
const dns = require("dns");
/**
 * Set error attributes on the span passed in params
 * @param err the error that we use for filling the attributes
 * @param span the span to be set
 * @param nodeVersion the node version
 */
exports.setError = (err, span, nodeVersion) => {
    const { code, message, name } = err;
    const attributes = {
        [AttributeNames_1.AttributeNames.DNS_ERROR_MESSAGE]: message,
        [AttributeNames_1.AttributeNames.DNS_ERROR_NAME]: name,
    };
    if (nodeVersion.startsWith('12')) {
        attributes[AttributeNames_1.AttributeNames.DNS_ERROR_CODE] = code;
    }
    span.setAttributes(attributes);
    const status = exports.parseErrorCode(code);
    status.message = message;
    span.setStatus(status);
};
/**
 * Returns the family attribute name to be set on the span
 * @param family `4` (ipv4) or `6` (ipv6). `0` means bug.
 * @param [index] `4` (ipv4) or `6` (ipv6). `0` means bug.
 */
exports.getFamilyAttribute = (family, index) => {
    return index ? `peer[${index}].ipv${family}` : `peer.ipv${family}`;
};
/**
 * Returns the span name
 * @param funcName function name that is wrapped (e.g `lookup`)
 * @param [service] e.g `http`
 */
exports.getOperationName = (funcName, service) => {
    return service ? `dns.${service}/${funcName}` : `dns.${funcName}`;
};
exports.parseErrorCode = (code) => {
    if (!code) {
        return { code: api_1.CanonicalCode.UNKNOWN };
    }
    else {
        switch (code) {
            case dns.BADQUERY:
            case dns.BADNAME:
            case dns.BADFAMILY:
            case dns.BADSTR:
            case dns.BADFLAGS:
            case dns.BADHINTS:
            case dns.FORMERR:
            case 'ERR_INVALID_OPT_VALUE':
            case 'ERR_INVALID_ARG_TYPE':
            case 'ERR_INVALID_ARG_VALUE':
            case 'ERR_INVALID_ADDRESS_FAMILY':
            case 'ERR_INVALID_CALLBACK':
            case 'ERR_INVALID_IP_ADDRESS':
            case 'ERR_INVALID_FILE_URL_HOST':
            case 'ERR_INVALID_FILE_URL_PATH':
            case 'ERR_MISSING_ARGS':
                return { code: api_1.CanonicalCode.INVALID_ARGUMENT };
            case dns.BADRESP:
            case dns.NODATA:
            case dns.FILE:
            case dns.NOMEM:
            case dns.DESTRUCTION:
            case dns.NONAME:
            case dns.LOADIPHLPAPI:
            case dns.ADDRGETNETWORKPARAMS:
                return { code: api_1.CanonicalCode.INTERNAL };
            case dns.SERVFAIL:
            case dns.NOTINITIALIZED:
            case dns.CONNREFUSED:
                return { code: api_1.CanonicalCode.UNAVAILABLE };
            case dns.NOTFOUND:
                return { code: api_1.CanonicalCode.NOT_FOUND };
            case dns.NOTIMP:
                return { code: api_1.CanonicalCode.UNIMPLEMENTED };
            case dns.REFUSED:
                return { code: api_1.CanonicalCode.RESOURCE_EXHAUSTED };
            case dns.CANCELLED:
                return { code: api_1.CanonicalCode.CANCELLED };
            case dns.TIMEOUT:
                return { code: api_1.CanonicalCode.DEADLINE_EXCEEDED };
            case dns.EOF:
                return { code: api_1.CanonicalCode.OUT_OF_RANGE };
            default:
                return { code: api_1.CanonicalCode.UNKNOWN };
        }
    }
};
exports.setLookupAttributes = (span, address, family) => {
    const attributes = {};
    const isObject = typeof address === 'object';
    let addresses = address;
    if (!isObject) {
        addresses = [{ address, family }];
    }
    else if (!(addresses instanceof Array)) {
        addresses = [
            {
                address: address.address,
                family: address.family,
            },
        ];
    }
    addresses.forEach((_, i) => {
        const peerAttrFormat = exports.getFamilyAttribute(_.family, i);
        attributes[peerAttrFormat] = _.address;
    });
    span.setAttributes(attributes);
};
/**
 * Check whether the given obj match pattern
 * @param constant e.g URL of request
 * @param obj obj to inspect
 * @param pattern Match pattern
 */
exports.satisfiesPattern = (constant, pattern) => {
    if (typeof pattern === 'string') {
        return pattern === constant;
    }
    else if (pattern instanceof RegExp) {
        return pattern.test(constant);
    }
    else if (typeof pattern === 'function') {
        return pattern(constant);
    }
    else {
        throw new TypeError('Pattern is in unsupported datatype');
    }
};
/**
 * Check whether the given dns request is ignored by configuration
 * It will not re-throw exceptions from `list` provided by the client
 * @param constant e.g URL of request
 * @param [list] List of ignore patterns
 * @param [onException] callback for doing something when an exception has
 *     occurred
 */
exports.isIgnored = (constant, list, onException) => {
    if (!list) {
        // No ignored urls - trace everything
        return false;
    }
    // Try/catch outside the loop for failing fast
    try {
        for (const pattern of list) {
            if (exports.satisfiesPattern(constant, pattern)) {
                return true;
            }
        }
    }
    catch (e) {
        if (onException) {
            onException(e);
        }
    }
    return false;
};
//# sourceMappingURL=utils.js.map